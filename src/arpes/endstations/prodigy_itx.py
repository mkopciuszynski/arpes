"""pyarpes plugin for SpecsLab Prodigy."""

from __future__ import annotations

import re
from datetime import UTC, datetime
from logging import DEBUG, INFO
from pathlib import Path
from typing import TYPE_CHECKING, Literal

import numpy as np
import xarray as xr

from arpes.constants import TWO_DIMENSION
from arpes.debug import setup_logger

if TYPE_CHECKING:
    from numpy.typing import NDArray

Measure_type = Literal["FAT", "SFAT"]
__all__ = ["export_itx", "load_itx", "load_sp2"]

LOGLEVELS = (DEBUG, INFO)
LOGLEVEL = LOGLEVELS[1]
logger = setup_logger(__name__, LOGLEVEL)

DIGIT_ID = 3


class ProdigyItx:
    """Class for Prodigy exported itx file.

    Args:
        list_style_itx_data(list[str] | None): list form of itx file
            (Path(itx_file).open().readlines())

    Attributes:
        params(dict[str, str | int float]): Measurement Parameters
        pixels(tuple[int, int]): The number of the pixcels of the intensity map.
        axis_info(dict[str, tuple[str, float, float, str]]): Information of axis
        wavename(str): The name of wave
        intensity(list[list[float]]): Phtoemission intensity
    """

    def __init__(self, list_style_itx_data: list[str] | None = None) -> None:
        """Initialize."""
        self.params: dict[str, str | float] = {}
        self.pixels: tuple[int, ...]
        self.axis_info: dict[str, tuple[str, float, float, str]] = {}
        self.wavename: str = ""
        self.intensity: NDArray[np.float64]
        if list_style_itx_data is not None:
            self.parse(list_style_itx_data)

    def parse(self, list_style_itx_data: list[str]) -> None:
        """Load and then parse the itx file generated by Prodigy.

        Args:
            list_style_itx_data(list[str]):list form of itx file generated by readlines()

        """
        intensity: list[float] = []
        itx_data = list(map(str.rstrip, list_style_itx_data))
        self.params = _parse_itx_head(itx_data, parse_type=True)
        if itx_data.count("BEGIN") != 1:
            msg = "This itx file contains more than one spectra."
            msg += " Use the itx file that Prodigy exports."
            raise RuntimeError(msg)
        for line in itx_data:
            if line.startswith(("IGOR", "BEGIN", "END")):
                continue
            if line.startswith(("X //", "X Note")):
                continue
            if line.startswith("WAVES/S/N"):
                self.pixels = tuple(int(i) for i in line[11:].split(sep=")")[0].split(sep=","))
                logger.debug(f"self.pixels: {self.pixels}")
                self.wavename = line.split(maxsplit=1)[-1].strip()[1:-1]
                continue
            if line.startswith("X SetScale"):
                tmp = _parse_setscale(line)
                self.axis_info[tmp[1]] = (tmp[0], tmp[2], tmp[3], tmp[4])
                logger.debug(f"self.axis_info[{tmp[1]}]: {self.axis_info[tmp[1]]}")
                continue
            intensity.extend(float(i) for i in line.split())
        self.intensity = np.array(intensity)
        logger.debug(f"shape of self.intensity: {self.intensity.shape}")

    def to_dataarray(self, **kwargs: str | float) -> xr.DataArray:
        """Export to Xarray.

        Args:
            **kwargs(str | float): Extra arguments. Forward to the attrs of the output xarray.

        Returns:
            xr.DataArray: pyarpess compatibility
        """

        def create_coords(
            axis_info: tuple[str, float, float, str],
            pixels: int,
        ) -> NDArray[np.float64]:
            """Create coordinate array from the axis_info."""
            assert axis_info[0] in {"I", "P"}
            if axis_info[0] == "I":
                return np.linspace(
                    float(axis_info[1]),
                    float(axis_info[2]),
                    num=pixels,
                    dtype=np.float64,
                )
            return np.linspace(
                float(axis_info[1]),
                float(axis_info[1]) + float(axis_info[2]) * (pixels - 1),
                num=pixels,
                dtype=np.float64,
            )

        common_attrs: dict[str, str | float] = {
            "spectrum_type": "cut",
            "angle_unit": "rad (theta_y)",
        }
        coords: dict[str, NDArray[np.float64]] = {}
        dims: list[str] = []
        # set angle axis
        if "x" in self.axis_info:
            coords["phi"] = np.deg2rad(
                create_coords(
                    axis_info=self.axis_info["x"],
                    pixels=self.pixels[0],
                ),
            )
            dims.append("phi")
        if "y" in self.axis_info:
            coords["eV"] = create_coords(
                axis_info=self.axis_info["y"],
                pixels=self.pixels[1],
            )
            dims.append("eV")
        if "z" in self.axis_info:
            coords["cycle"] = create_coords(
                axis_info=self.axis_info["z"],
                pixels=self.pixels[2],
            )
            dims = ["cycle", *dims]
        if "w" in self.axis_info:
            coords["ch2"] = create_coords(
                axis_info=self.axis_info["w"],
                pixels=self.pixels[3],
            )
            dims = ["ch2", *dims]

        attrs = {**common_attrs, **self.params}
        if "y" in self.axis_info:
            attrs["enegy_unit"] = self.axis_info["y"][3]
        if "d" in self.axis_info:
            attrs["count_unit"] = self.axis_info["d"][3]
        attrs = _angle_unit_to_rad(attrs)
        logger.debug(f"dims: {dims}")
        data_array = xr.DataArray(
            data=self.intensity.reshape(_pixel_to_shape(self.pixels)),
            coords=coords,
            dims=dims,
            attrs=attrs,
            name=self.wavename,
        )
        for k, v in kwargs.items():
            data_array.attrs[k] = v
        return data_array

    @property
    def integrated_intensity(self) -> np.float64:
        """Return the integrated intensity."""
        return np.sum(self.intensity)


def _pixel_to_shape(pixel: tuple[int, ...]) -> tuple[int, ...]:
    if len(pixel) == TWO_DIMENSION:
        return pixel
    if len(pixel) == TWO_DIMENSION + 1:
        return pixel[2], pixel[0], pixel[1]
    return pixel[3], pixel[2], pixel[0], pixel[1]


def convert_itx_format(
    arr: xr.DataArray,
    *,
    add_notes: bool = False,
) -> str:
    """Export pyarpes spectrum data to itx file.

    Note: that the wave name is changed based on the ID number.

    Args:
        arr(xr.DataArray):  DataArray to export
        add_notes(bool): if True, add some info to notes in wave.(default: False)

    Returns:
        str: itx formatted ARPES data
    """
    assert isinstance(arr, xr.DataArray)
    if "User Comment" in arr.attrs:
        arr.attrs["User Comment"] += ";" + _user_comment_from_attrs(arr)
    else:
        arr.attrs["User Comment"] = _user_comment_from_attrs(arr)
    start_energy: float = arr.indexes["eV"][0]
    step_energy: float = arr.indexes["eV"][1] - arr.indexes["eV"][0]
    end_energy: float = arr.indexes["eV"][-1]
    parameters = arr.attrs
    parameters["StartEnergy"] = start_energy
    parameters["StepWidth"] = step_energy
    itx_str: str = _build_itx_header(
        arr.attrs,
        comment=arr.attrs.get("User Comment", ""),
        measure_mode=arr.attrs.get("scan_mode", "Fixed Analyzer Transmission"),
    )
    phi_pixel = len(arr.coords["phi"])
    energy_pixel = len(arr.coords["eV"])
    id_number = parameters.get("id", parameters.get("Spectrum ID"))
    wavename = "ID_" + str(id_number).zfill(DIGIT_ID)
    itx_str += f"WAVES/S/N=({phi_pixel},{energy_pixel}) '{wavename}'\nBEGIN\n"
    try:
        intensities_list = arr.to_dict()["data_vars"]["spectrum"]["data"]
    except KeyError:
        intensities_list = arr.to_dict()["data"]
    for a_intensities in intensities_list:
        itx_str += " ".join(map(str, a_intensities)) + "\n"
    itx_str += "END\n"
    start_phi_deg: float = np.rad2deg(arr.indexes["phi"][0])
    end_phi_deg: float = np.rad2deg(arr.indexes["phi"][-1])
    itx_str += (
        f"""X SetScale/I x, {start_phi_deg}, {end_phi_deg}, "deg (theta_y)", '{wavename}'\n"""
    )
    itx_str += f"""X SetScale/I y, {start_energy}, {end_energy}, "eV", '{wavename}'\n"""

    itx_str += """X SetScale/I d, 0, 0, "{}", '{}'\n""".format(
        arr.attrs.get("count_unit", "cps"),
        wavename,
    )
    if add_notes:
        itx_str += """X Note /NOCR '{}' "{}"\r\n""".format(
            wavename,
            arr.attrs["User Comment"],
        )
        excitation_energy = arr.attrs.get("hv", parameters.get("Excitation Energy"))
        itx_str += f"""X Note /NOCR '{wavename}', "Excitation Energy:{excitation_energy}"\r\n"""
        # parameter should be recorded.
        # x, y, z (if defined)
        #
    return itx_str


def export_itx(
    file_name: str | Path,
    arr: xr.DataArray,
    *,
    add_notes: bool = False,
) -> None:
    """Export pyarpes spectrum data to itx file.

    Args:
        file_name(str | Path): file name for export
        arr(xr.DataArray): pyarpes DataArray
        add_notes(bool): if True, add some info to notes in wave (default: False)
    """
    with Path(file_name).open(mode="w", encoding="UTF-8") as itx_file:
        itx_file.write(convert_itx_format(arr, add_notes=add_notes))


def load_itx(
    path_to_file: Path | str,
    **kwargs: str | float,
) -> xr.DataArray | list[xr.DataArray]:
    """Load and parse the itx data.

    Args:
        path_to_file (Path | str): Path to itx file.
        kwargs (str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """

    def find_indices(
        list_to_check: list[str],
        str_to_find: str = "",
    ) -> list[int]:
        """Get index of All Occurrences of Element in a Python List.

        Args:
            list_to_check(list[str]): list for check
            str_to_find(str): string to find, default to "".

        Returns:
            list[int]: the list of all indexes.
        """
        return [idx for idx, value in enumerate(list_to_check) if value == str_to_find]

    with Path(path_to_file).open(mode="r", encoding="UTF-8") as itx_file:
        itx_data: list[str] = itx_file.readlines()
        itx_data = list(map(str.rstrip, itx_data))
        if itx_data.count("BEGIN") == 1:
            prodigy_itx = ProdigyItx(itx_data)
            data = prodigy_itx.to_dataarray()
            for k, v in kwargs.items():
                data.attrs[k] = v
            return data
        end_index_list = [*find_indices(itx_data, ""), -1]
        slice_list = []
        for i in range(len(end_index_list)):
            if i == 0:
                slice_list.append(slice(0, end_index_list[0]))
            else:
                slice_list.append(slice(end_index_list[i - 1], end_index_list[i]))
        multi_itx_data = []
        for sl in slice_list:
            a_itx_data = ProdigyItx(itx_data[sl]).to_dataarray()
            for k, v in kwargs.items():
                a_itx_data[k] = v
            multi_itx_data.append(a_itx_data)
        return multi_itx_data


def load_sp2(
    path_to_file: Path | str,
    **kwargs: str | float,
) -> xr.DataArray:
    """Load and parse sp2 file.

    Args:
        path_to_file(Path | str): Path to sp2 file
        kwargs(str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """
    params: dict[str, str | float] = {}
    data: list[float] = []
    pixels: tuple[int, int] = (0, 0)
    coords: dict[str, NDArray[np.float64]] = {}
    with Path(path_to_file).open(encoding="Windows-1252") as sp2file:
        for line in sp2file:
            if line.startswith("#"):
                params = _parse_sp2_comment(line, params)
            elif line.startswith("P"):
                pass
            elif pixels != (0, 0):
                data.append(float(line))
            else:
                pixels = (
                    int(line.split()[1]),
                    int(line.split()[0]),
                )
    if pixels != (0, 0):
        if isinstance(params["X Range"], str):
            e_range = [float(i) for i in re.findall(r"-?[0-9]+\.?[0-9]*", params["X Range"])]
            coords["eV"] = np.linspace(e_range[0], e_range[1], pixels[1], dtype=np.float64)
        if isinstance(params["Y Range"], str):
            a_range = [float(i) for i in re.findall(r"-?[0-9]+\.?[0-9]*", params["Y Range"])]
            corrected_angles = _correct_angle_region(a_range[0], a_range[1], pixels[0])

            coords["phi"] = np.deg2rad(
                np.linspace(corrected_angles[0], corrected_angles[1], pixels[0]),
            )
    params["spectrum_type"] = "cut"
    params = _angle_unit_to_rad(params)
    data_array: xr.DataArray = xr.DataArray(
        np.array(data).reshape(pixels),
        coords=coords,
        dims=["phi", "eV"],
        attrs=params,
    )
    data_array.coords["phi"].attrs["units"] = "Radians"
    for k, v in kwargs.items():
        data_array.attrs[k] = v
    return data_array


def _angle_unit_to_rad(params: dict[str, str | float]) -> dict[str, str | float]:
    """Correct unit angle from degrees to radians in params object.

    Just a helper function.
    """
    for angle in ("beta", "chi", "theta", "psi", "phi"):
        if angle in params:
            params[angle] = np.deg2rad(params[angle])
        if angle + "_offset" in params:
            params[angle + "_offset"] = np.deg2rad(params[angle + "_offset"])
    return params


def _parse_sp2_comment(line: str, params: dict[str, str | float]) -> dict[str, str | float | int]:
    try:
        params[line[2:].split("=", maxsplit=1)[0].strip()] = int(
            line[2:].split("=", maxsplit=1)[1].strip(),
        )
    except ValueError:
        try:
            params[line[2:].split("=", maxsplit=1)[0].strip()] = float(
                line[2:].split("=", maxsplit=1)[1].strip(),
            )
        except ValueError:
            params[line[2:].split("=", maxsplit=1)[0].strip()] = (
                line[2:].split("=", maxsplit=1)[1].strip()
            )
    except IndexError:
        pass
    return params


header_template = """IGOR
X //Created Date (UTC): {}
X //Created by: R. Arafune
X //Acquisition Parameters:
X //Scan Mode         = {}
X //User Comment      = {}
X //Analysis Mode     = UPS
X //Lens Mode         = {}
X //Lens Voltage      = {}
X //Spectrum ID       = {}
X //Analyzer Slits    = {}
X //Number of Scans   = {}
X //Number of Samples = {}
X //Scan Step         = {}
X //DwellTime         = {}
X //Excitation Energy = {}
X //Kinetic Energy    = {}
X //Pass Energy       = {}
X //Bias Voltage      = {}
X //Detector Voltage  = {}
X //WorkFunction      = {}
"""


def _build_itx_header(
    param: dict[str, str | float],
    comment: str = "",
    measure_mode: Measure_type = "FAT",
) -> str:
    """Make itx file header.

    Parameters
    ----------
    param: dict[str, str | float]
        Spectrum parameter
    spectrum_id: int
        Unique id for spectrum
    num_scan: int
        Number of scan.
    comment: str
        Comment string.  Used in "//User Comment"
    measure_mode : Measure_type
        Measurement mode (FAT/SFAT)

    Returns:
    -------
    str
        Header part of itx
    """
    mode = "Fixed Analyzer Transmission" if measure_mode == "FAT" else "Snapshot"
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M:%S.%f")
    if param["User Comment"]:
        comment += ";" + str(param["User Comment"])
    return header_template.format(
        now,
        mode,
        param["User Comment"],
        param.get("lens_mode", param.get("Lens Mode")),
        param.get("Lens Voltage", param.get("lens voltage")),
        param.get("id", param.get("Spectrum ID")),
        param.get("Analyzer Slits", param.get("analyzer_slits")),
        param.get("Number of Scans", param.get("number_of_scans")),
        param.get("Number of Samples", param.get("number_of_samples")),
        param["StepWidth"],
        param.get("DwellTime", param.get("dwell_time")),
        param.get("hv", param.get("Excitation Energy")),
        param["StartEnergy"],
        param.get("pass_energy", param.get("Pass Energy", 5)),
        param.get("Bias Voltage", param.get("bias_voltage")),
        param.get("mcp_voltage", param.get("Detector Voltage")),
        param.get("workfunction", param.get("WorkFunction", 4.401)),
    )


def _correct_angle_region(
    angle_min: float,
    angle_max: float,
    num_pixel: int,
) -> tuple[float, float]:
    """Correct the angle value to fit igor.

    Parameters
    ----------
    angle_min: float
        Minimum angle of emission
    angle_max: float
        Maximum angle of emission
    num_pixel: int
        The number of pixels for non-energy channels (i.e. angle)

    Returns:
    -------
    tuple[float, float]
        minimum angle value and maximum angle value
    """
    diff: float = ((angle_max - angle_min) / num_pixel) / 2
    return angle_min + diff, angle_max - diff


def _parse_itx_head(
    itx_data: list[str],
    *,
    parse_type: bool = False,
) -> dict[str, str | int | float]:
    """Parse Common head part.

    Parameters
    ----------
    itx_data : list[str]
        Contents of itx data file (return on readlines())
    parse_type: bool
        if true the type of the value in head part is analyzed.

    Returns:
    -------
    dict[str, str | int | float]
        Common head data
    """
    common_params: dict[str, str | int | float] = {}
    for line in itx_data[1:]:
        if not line.startswith("X //") or line.startswith("X //Acquisition Parameters"):
            continue
        if line.startswith("X //User Comment"):
            common_params = _parse_user_comment(line, common_params)
        elif "=" in line:
            line_data = line[4:].split("=", maxsplit=1)
            common_params[line_data[0].strip()] = line_data[1].strip()
        elif ":" in line:
            line_data = line.split(":", maxsplit=1)
            common_params[line_data[0][4:].strip()] = line_data[1].strip()
    if parse_type:
        common_params = _update_params_by_type(common_params)
    return common_params


def _user_comment_from_attrs(dataarray: xr.DataArray) -> str:
    key_pos: set[str] = {"x", "y", "z"}
    key_angle: set[str] = {"beta", "chi", "psi"}
    user_comment = ""
    for key, value in dataarray.attrs.items():
        if key in key_pos and not np.isnan(value):
            logger.debug(f"key: {key}, value: {type(value)} ")
            user_comment += str(key) + ":" + f"{value}" + ";"
        if key in key_angle:
            user_comment += str(key) + ":" + f"{np.rad2deg(value)};"
    return user_comment


def _update_params_by_type(
    common_params: dict[str, str | int | float],
) -> dict[str, str | int | float]:
    """Parse type in common params.

    Helper function to parse the type of the value in common params

    Parameters
    ----------
    common_params: dict[str, str | int | float]
        common params to be parsed

    Returns:
    -------
    dict[str, str | int | float]
        parsed common_params
    """
    for k, v in common_params.items():
        if isinstance(v, str) and v.isdecimal():
            common_params[k] = int(v)
        else:
            try:
                common_params[k] = float(v)
            except ValueError:
                common_params[k] = v
    return common_params


def _parse_user_comment(
    line: str,
    common_params: dict[str, str | int | float],
) -> dict[str, str | int | float]:
    """Parse "USER COMMENT" line.

    Helper function: Treating the USER COMMENT

    Parameters
    ----------
    line: str
        line stringl
    common_params: dict[str, str| int, float]
        common parameters

    Returns:
    -------
    dict[str, str| int|float]
        common parameters including "User COMMENT" information
    """
    user_comment: str = line.split("=", maxsplit=1)[1].strip()
    logger.debug(f"user_comement: {user_comment}")
    common_params["User Comment"] = str(common_params.get("User Comment", "")) + user_comment
    line_data: list[str] = user_comment.split(";")
    for item in line_data:
        if len(item) == 0:
            continue
        if ":" in item:
            key, value = item.split(":", maxsplit=1)
            common_params[key] = value
        else:
            common_params[item] = True
    return common_params


def _parse_setscale(line: str) -> tuple[str, str, float, float, str]:
    """Parse setscale.

    Args:
        line(str): line should start with "X SetScale"

    Returns:
        tuple[str, str, float, float, str]
    """
    assert "SetScale" in line
    flag: str
    dim: str
    num1: float
    num2: float
    unit: str
    setscale = line.split(",", maxsplit=5)
    if "/I" in setscale[0]:
        flag = "I"
    elif "/P" in line:
        flag = "P"
    else:
        flag = ""
    dim = setscale[0][-1]
    if dim not in {"x", "y", "z", "d", "t"}:
        msg = "Dimension is not correct"
        raise RuntimeError(msg)
    unit = setscale[3].strip()[1:-1]
    num1 = float(setscale[1])
    num2 = float(setscale[2])
    return (flag, dim, num1, num2, unit)
